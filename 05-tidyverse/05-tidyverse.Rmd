---
title: "Lecture 5: Tidyverse"
subtitle: "<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: Grant McDermott | University of Oregon
date: EC 607 #"`r format(Sys.time(), '%d %B %Y')`"
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts] 
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
library(knitr)
opts_chunk$set(
  fig.align="center", #fig.width=6, fig.height=4.5, 
  # out.width="748px", #out.length="520.75px",
  dpi=300, #fig.path='Figs/',
  cache=F#, echo=F, warning=F, message=F
  )
```

class: inverse, center, middle

# Prologue

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---

# Student presentation: Tidy data

Resources:
- Paper: [*Tidy Data*](https://vita.had.co.nz/papers/tidy-data.pdf) (Hadley Wickham, 2014 JSS)
- Vignette: [Tidy data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) (from the `tidyr` package)

--

</br>

Key points:
1. Each variable forms a column.
2. Each observation forms a row.
3. Each type of observational unit forms a table.

---

# Checklist

☑ You should already have installed the [tidyverse](https://www.tidyverse.org/) last week.

☑ You will also need the [nycflights13](hhttps://github.com/hadley/nycflights13) package.
- Install it now: `install.packages("nycflights13")`

--

</br>

Today is the last lecture where I'll be using slides (i.e. "forcing" you to type out commands by hand).
- From next lecture on we'll be switching to HMTL notebooks, but I still encourage you to avoid copy+paste as much as possible.

---
class: inverse, center, middle

# Tidyverse basics

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---

# Tidyverse vs. base R

Much digital ink has been spilled over the "tidyverse vs. base R" debate.

--

I won't delve into this debate here, because I think the answer is [obvious](http://varianceexplained.org/r/teach-tidyverse/): We should teach (and learn) the tidyverse first.
- The documentation and community support are outstanding.
- Having a consistent philosophy and syntax makes it much easier to learn.
- For data cleaning, wrangling and plotting... the tidyverse is really a no-brainer.<sup>1</sup>

.footnote[
<sup>1</sup> I should say that I'm also a fan of the [data.table](https://github.com/Rdatatable/data.table/wiki) package for data work. I may come back to this package once we reach the big data section of the course.
]

--

But this certainly shouldn't put you off learning base R alternatives.
- Base R is extremely flexible and powerful (esp. when combined with other libraries).
- There are some things that you'll have to venture outside of the tidyverse for.
- A combination of tidyverse and base R is often the best solution to a problem.

---

# Tidyverse vs. base R (cont.)

One point of convenience is that there is often a direct correspondence between a tidyverse command and its base R equivalent. 

These invariably follow a `tidyverse::snake_case` vs `base::period.case` rule. E.g. see:
- `?readr::read_csv` vs `?utils::read.csv`
- `?tibble::data_frame`vs `?base::data.frame`
- `?dplyr::if_else` vs `?base::ifelse`
- etc.
  
If you call up the above examples, you'll see that the tidyverse alternative typically offers some enhancements or other useful options (and sometimes restrictions) over its base counterpart.
- Remember: There are always many ways to achieve a single goal in R.

---

# Tidyverse packages

Let's load the tidyverse meta-package and check the output.
```{r}
library(tidyverse)
```

--

We see that we have actually loaded a number of packages (which could also be loaded individually): `ggplot2`, `tibble`, `dplyr`, etc.
- We can also see information about the package versions and some namespace conflicts (remember those from last week).

---

# Tidyverse packages (cont.)

The tidyverse actually comes with a lot more packages than those that are just loaded automatically.<sup>1</sup>
```{r}
tidyverse_packages()
```

We'll use several of these additional packages during the remainder of this course.
— E.g. The `lubridate` package for working with dates and the `rvest` package for webscraping.
- However, bear in mind that these packages will have to be loaded separately.

.footnote[
<sup>1</sup> It also includes a lot of dependencies upon installation.
]

---

# Tidyverse packages (cont.)

I hope to cover most of the tidyverse packages over the length of this course.

Today, however, I'm only really going to focus on two packages: 
1. `dplyr`
2. `tidyr`

These are the workhorse packages for cleaning and wrangling data. They are thus the ones that you will likely make the most use of (alongside `ggplot2`, which we already met back in Lecture 1).
- Data cleaning and wrangling occupies an inordinate amount of time, no matter where you are in your research career.

---

# An aside on pipes: %>%

We already learned about pipes in our lecture on the bash shell. In R, the pipe operator is denoted `%>%` and is automatically loaded with the tidyverse.
  
I want to reiterate how cool pipes are, and how using them can dramatically improve the experience of reading and writing code. Compare:

```{r, eval = F}
## These next two lines of code do exactly the same thing.
mpg %>% filter(manufacturer=="audi") %>% group_by(model) %>% summarise(hwy_mean = mean(hwy))
summarise(group_by(filter(mpg, manufacturer=="audi"), model), hwy_mean = mean(hwy))
```

--

The first line reads from left to right, exactly how I thought of the operations in my head. 
- Take this object (mpg), do this (filter), then do this (group by), etc.

The second line totally inverts this logical order (the final operation comes first!) 
- Who wants to read things inside out?

---

# An aside on pipes: %>% (cont.)

The piped version of the code is even more readable if we write it over several lines. Here it is again and, this time, I'll run it for good measure so you can see the output:

```{r}
mpg %>% 
  filter(manufacturer=="audi") %>% 
  group_by(model) %>% 
  summarise(hwy_mean = mean(hwy))
```

Remember: Using vertical space costs nothing and makes for much more readable/writeable code than cramming things horizontally.

--

PS — The pipe is originally from the [magrittr](https://magrittr.tidyverse.org/) package ([geddit?](https://en.wikipedia.org/wiki/The_Treachery_of_Images)), which can do some other cool things if you're inclined to explore.


---
class: inverse, center, middle

# dplyr

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---

# Key dplyr verbs

There are five key dplyr verbs that you need to learn.

1. `filter()`: Filter (i.e. subset) rows based on their values.

2. `arrange()`: Arrange (i.e. reorder) rows based on their values.

3. `select()`: Select (i.e. subset) columns by their names: 

4. `mutate()`: Create new columns.

5. `summarise()`: Collapse multiple rows into a single summary value.<sup>1</sup>

.footnote[
<sup>1</sup> `summarize()` with a "z" works too. R doesn't discriminate against uncivilised nations of the world.
]

--

</br>

Let's practice these commands together using the starwars data frame that comes pre-packaged with `dplyr`. 

---

# 1) dplyr::filter()

We can chain multiple filter commands with the pipe (`%>%`), or just separate them within a single filter command using commas.
```{r}
starwars %>% 
  filter( 
    species == "Human", 
    height >= 190
    ) 
```

---

# 1) dplyr::filter() *cont.*

Regular expressions work well too.
```{r}
starwars %>% 
  filter(grepl("Skywalker", name))
```

---

# 1) dplyr::filter() *cont.*

A very common use case is identifying (or removing) missing data cases. 
```{r}
starwars %>% 
  filter(is.na(height))
```

--

</br>

To remove missing observations, simply use negation: `filter(!is.na(height))`.

---

# 2) dplyr::arrange()

```{r}
starwars %>% 
  arrange(birth_year)
```

--

*Note.* Arranging on a character-based column (i.e. strings) will sort alphabetically. Try this yourself by arranging according to the "name" column.

---

# 2) dplyr::arrange() *cont.*

We can also arrange items in descending order using `arrange(desc())`.
```{r}
starwars %>% 
  arrange(desc(birth_year))
```

---

# 3) dplyr::select()

Use commas to select multiple columns out of a data frame. (You can also use "first:last" for consecutive columns). Deselect a column with "-".
```{r}
starwars %>% 
  select(name:skin_color, species, -height)
```

---

# 3) dplyr::select() *cont.*

You can also rename some (or all) of your selected variables in place.
```{r}
starwars %>%
  select(alias=name, crib=homeworld, sex=gender) 
```

---

# 3) dplyr::select() *cont.*

The `select(contains(PATTERN))` option provides a nice shortcut in relevant cases.
```{r}
starwars %>% 
  select(name, contains("color"))
```

---

# 3) dplyr::select() *cont.*

The `select(..., everything())` option is another useful shortcut if you only want to bring some variable(s) to the "front" of a data frame.

```{r}
starwars %>% 
  select(species, homeworld, everything())
```

---

# 4) dplyr::mutate()

You can create new columns from scratch, or (more commonly) as transformations of existing columns.
```{r}
starwars %>% 
  select(name, birth_year) %>%
  mutate(dog_years = birth_year * 7)
```

---

# 4) dplyr::mutate() *cont.*

Boolean, logical and conditional operators all work well with `mutate()` too.
```{r}
starwars %>% 
  select(name, height) %>%
  filter(name %in% c("Luke Skywalker", "Anakin Skywalker")) %>% 
  mutate(tall1 = height > 180) %>%
  mutate(tall2 = ifelse(height > 180, "Tall", "Short")) ## Same effect, but can choose labels
```

---

# 5) dplyr::summarise()

Particularly useful in combination with the `group_by()` command.
```{r}
starwars %>% 
  group_by(species, gender) %>% 
  summarise(mean_height = mean(height, na.rm = T))
```

---

# 5) dplyr::summarise() *cont.*

Note that including "na.rm = T" is usually a good idea with summarise functions. Otherwise, any missing value will propogate to the summarised value too.
```{r}
## Probably not what we want
starwars %>% 
  summarise(mean_height = mean(height))
## Much better
starwars %>% 
  summarise(mean_height = mean(height, na.rm = T))
```

---

# Other dplyr goodies

`group_by()` and `ungroup()`: For (un)grouping.
- Particularly useful with the `summarise()` and `mutate()` commands, as we've already seen.

`slice()`: Subset rows by position rather than filtering by values.
- E.g. `starwars %>% slice(c(1, 5))`

`pull()`: Extract a column from as a data frame as a vector or scalar.
- E.g. `starwars %>% filter(gender=="female") %>% pull()`

`count()` and `distinct()`: Number and isolate unique observations.
- E.g. `starwars %>% count(species)`, or `starwars %>% distinct(species)`
- You could also use a combination of `mutate()`, `group_by()`, and `n()`, e.g. `starwars %>% group_by(species) %>% mutate(num = n())`.

---

# Joining operations

One of the mainstays of the dplyr package is merging data with the [join family](https://cran.r-project.org/web/packages/dplyr/vignettes/two-table.html) of commands. 

For the simple examples that I'm going to show here, we'll need some data sets that come bundled with the [nycflights13 package](http://github.com/hadley/nycflights13). 
- Load it now and then inspect these data frames in your own console.

```{r, echo = F}
library(nycflights13)
```
```{r, eval = F}
library(nycflights13)
flights 
planes
```

---

# Joining operations (cont.)

Let's before a [left join](https://stat545.com/bit001_dplyr-cheatsheet.html#left_joinsuperheroes-publishers) on the flights and planes datasets. (*Note*: I'm going subset columns after the join, but only to help readability on this slide.)
```{r}
left_join(flights, planes) %>%
  select(year, month, day, dep_time, arr_time, carrier, flight, tailnum, type, model)
```

---

# Joining operations (cont.)

(*continued from previous slide*)

Note that `dplyr` made a reasonable guess about which columns to join on (i.e. columns that share the same name). It also told us its choices: 

```
*## Joining, by = c("year", "tailnum")
```

However, there's an obvious problem here: the variable "year" does not have a consistent meaning across our joining datasets.
- In one it refers to the *year of flight*, in the other it refers to *year of construction*.

Luckily, it's easy to fix this problem simply by being explicit. You can also rename any ambiguous columns to avoid confusion. Try the following in your console:
```{r, eval = F}
left_join(
  flights
  planes %>% rename(year_built = year), 
  by = c("tailnum"="tailnum") ## Be specific which columns we are joining on.
  ) 
```

---
class: inverse, center, middle

# tidyr

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---

# Key tidyr verbs

1. `gather()`: Gather (or "melt") wide data into long format

2. `spread()`: Spread (or "cast") long data into wide format. 

3. `separate()`: Separate (i.e. split) one column into multiple columns.

4. `unite()`: Unite (i.e. combine) multiple columns into one.

--

Let's practice these verbs together in class.
- Side question: Which of `gather()` vs `spread()` produces "tidy" data?
  
---

# 1) `tidyr::gather()`

```{r}
stocks <- data.frame(
  time = as.Date('2009-01-01') + 0:1,
  X = rnorm(2, 0, 1),
  Y = rnorm(2, 0, 2),
  Z = rnorm(2, 0, 4)
)
stocks
tidy_stocks <- stocks %>% gather(stock, price, -time) #<<
tidy_stocks
```

---

# 2) `tidyr::spread()`

```{r}
tidy_stocks %>% spread(stock, price) #<<
tidy_stocks %>% spread(time, price) #<<
```

---

# 3) `tidyr::separate()`

```{r}
economists <- data.frame(Name = c("Adam.Smith", "Paul.Samuelson", "Milton.Friedman"))
economists
economists %>% separate(Name, c("First", "Last")) #<<
```

---

# 4) `tidyr::unite()` 

```{r}
gdp <- data.frame(
  yr = rep(2016, times = 4),
  qtr = 1:4,
  gdp = rnorm(4, mean = 100, sd = 2)
)
gdp 
gdp %>% unite(yr_qtr, c("yr", "qtr"), sep = "q") #<<
```

---

# Other `tidyr` goodies

- Use `separate_rows()` to split up cells that contain multiple fields or observations (a frustringly common occurence with survey data).
```{r}
data_frame(
  Person = c("Jack", "Jill"),
  Occupation = c("Homemaker", "Philosopher, Philanthropist, Troublemaker") ## The second row of our y column contains multiple observations.
  ) %>% 
  separate_rows(Occupation) #<<
```

---

# Other `tidyr` goodies (cont.)

- Use `crossing()` to get the full combination of a group of variables.<sup>1</sup>

```{r}
crossing(side=c("left", "right"), position=c("top", "bottom"))
```

- See `?expand()` and `?complete()` for more specialised functions that allow you to fill in (implicit) missing data or variable combinations in existing data frames.

.footnote[
[1] Base R alternative: `expand.grid()`.
]  
  
