---
title: "Functions in R: 2) Advanced concepts"
author:
  name: Grant R. McDermott
  affiliation: University of Oregon | EC 607
  # email: grantmcd@uoregon.edu
date: Lecture 11  #"`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    theme: flatly
    highlight: haddock 
    # code_folding: show
    toc: yes
    toc_depth: 4
    toc_float: yes
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, dpi=300)
```

*Note: This is the second of three lectures on programming. Please take a look at the [first lecture](https://raw.githack.com/uo-ec607/lectures/master/10-funcs-intro/10-funcs-intro.html) if you haven't gone through it yet. Today, we'll build on that foundation by tackling some more advanced issues that arise when writing and working with functions in R. In particular, I'm going to focus on function debugging, catching user errors, and caching results.*

## Software requirements

### R packages 

- **New:** `R.cache`, `tictoc`
- **Already used:** `tidyverse` 

Install (if necessary) and load these packages now:

```{r, cache=F, message=F}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(R.cache, tictoc, tidyverse)
```

Note that when you first install the [R.cache package](https://cran.r-project.org/web/packages/R.cache/index.html), it will ask you if you wish to create a default `~/.Rcache` directory that will hold all of your cache files. I recommend that you say yes by entering "y".^[The alternative is create a temporary directory for this session only. This is okay for experimentation, but decidedly unhelpful when the goal caching is to persist output and evaluated code across sessions.]

We will also be working with our simple `square()` function from the previous lecture. Let's create it again quickly.

```{r square}
square <- 
  function(x = 1) {
    x_sq <- x^2 
    df <- tibble(value=x, value_squared=x_sq)
    return(df)
  }
```

## Debugging

*<b>Note:</b> This debugging section will be run interactively and I've set most of the below code chunks to `eval=F` in the R Markdown document. (So don't be suprised if the knitted HTML document doesn't contain output correspoding to what I'm talking about in the text.) My advice is to run the code chunks yourself and then follow along with the text.*

### Debugging with RStudio

R and the RStudio IDE provide a number of excellent tools for debugging. We'll walk through these together in a live coding session in a minute, but here is a visual summary taken directly from the [RStudio IDE Cheat Sheet](https://www.rstudio.com/resources/cheatsheets/#ide).^[I mentioned this in an earlier lecture, but RStudio hosts a bunch of excellent [cheat sheets](https://www.rstudio.com/resources/cheatsheets/) that are all worth checking out.] 

![Source: https://www.rstudio.com/resources/cheatsheets/#ide](pics/rstudio-debug.png)

I recommend the `debugonce()` function.^[The generic `debug()` function works well too, but there are some edge cases where running it inside the RStudio IDE can result in a recursive debugging loop hell. So I advise avoiding `debug()` unless you are running R (or calling R scripts) directly from the terminal.] This will cause you to enter *debug mode*, which is really allowing you to "step inside" the function. Let's practice some examples.

### Simple example (live coding)

```{r debugonce, eval=F}
debugonce(square)
square("1")
```

Here's summary of some of the things you should see:

- **Source pane.** Green arrow with highlighted text indicating which line will be run next.
- **Environment pane.** No longer in Global Environment, but rather specifically in the "square()" function environment. Also note the new "Traceback" sub-pane. Where you are in the code and what you've done to get to this point. Not that informative with this simple example, but can be very helpful when you have long, complicated functions.
- **Console pane.** The prompt has changed from `>` to (something like) `Browse[1]>`, indicating that you are now in the R environment browser. You also have several control buttons across the top ("Next", "Continue", "Stop", etc.), which allow you to walk through the code in different ways.

In this case, the problem is obvious and R would have spat out an informative message regardless. But it still illustrates the general principle.

RStudio will only throw out automated errors when there is something wrong with the R code (i.e. it yields an R error), not when there is something wrong with your code logic.

### More complicated example (live coding)

```{r felm, error=TRUE}
source("R/felm-3w.R")
# error
felm_marg_effects(reg1, "treat_post", "income", "initial_income", 50000) # Error in as.matrix(cov_x1d3_x1x2d3)[i, i] : subscript out of bounds
```


## Catching (user) errors and mistakes

In the previous lecture, we implicitly assumed that the user knows exactly how to use our function. However, this isn't always the case. A related, but more complicated, case is when we mistakenly input the wrong type of argument into a function. For example, consider what happens when we mistakenly enter a string rather than a number in our `square` function from last time.

```{r square_err1, error=TRUE}
square("1") 
```

This may just seem like a case of particularly dumb user error. However --- trust me --- its very easy to run into this category of problem when you have a complex analysis that consists of, say, a series of nested functions. (One function calling another, calling another...) For whatever reason, a single function or iteration may produce slightly different output than expected and this can bring your entire analysis crashing to its knees, because the output can't be used in the next part of the chain. This is especially frustrating when you are running a multicore process (e.g. a parallel Monte Carlo simulation), since the program will first complete the *entire* run --- perhaps taking several hours --- before informing you right at the end that there was an error somewhere and no results (even for the valid iterations!) have been retained. 

Luckily, there are several approaches to guarding against these kind of mistakes. I'll briefly run through what I see as the three main options below. 

1. Function-specific `ifelse` statements
2. Improved generality with `base::tryCatch()`
3. Use `purrr::safely()` and family

### Option 1: Function-specific `ifelse` statements

In this particular example, we can check whether the input argument is a numeric and use an `ifelse` statement to produce a warning/error message if it fails this test. Let's demonstrate how this might work in practice by defining a slightly modified version of our function, which I'll call `square_ifelse`.
```{r square_ifelse}
square_ifelse <- 
  function (x = 1) { 
    if (is.numeric(x)) { ## Check that this is a valid argument to our function.
      x_sq <- x^2 
      df <- tibble(value=x, value_squared=x_sq)
      return(df) 
    } else { ## Return a warning message if not.
      message("Sorry, you need to provide a numeric input variable.")
    }
  }
```

Test it.
```{r square_ifelse_test}
square_ifelse("1") ## Will trigger our warning message.
square_ifelse(1) ## Works.
```

### Option 2: Improved generality with `base::tryCatch()`

Another, more general option is to use the `base::tryCatch()` function for handling errors and warnings. Let me demonstrate its usefulness with two separate examples. 

#### 2.1) Wrap `tryCatch()` around an entire function

The first simply wraps a generic `tryCatch` statement *around* our existing `square` function. Note the invocation of R's in-built "error" class, which in turn is passed to another in-built function called `message`. Basically, we are telling R to produce a particular message whenever it recognizes that an error (any error!) has occurred while executing our bespoke function.
```{r trycatch1}
tryCatch(
  square("three"), 
  error = function(e) message("Sorry, something went wrong. Did you try to square a string instead of a number?")
  )
```

This first example works well, but it has the downside of throwing out everything that went into the function in favour of a single error message. Not only that, but it could throw out potentially valid input-output because of a single error. To see this more clearly, let's feed our function a vector of inputs, where only one input is invalid.

```{r trycatch2}
tryCatch(
  square(c(1,2,"three")), 
  error = function(e) message("Sorry, something went wrong. Did you try to square a string instead of a number?")
  )
```
So we simply get an error message, even though some (most) of our inputs were valid. In an ideal world, we would have retained the input-output from the valid parameters (i.e. 1 and 2) and only received an error message for the single invalid case (i.e. "three"). This leads us to our second example...

#### 2.2) Use `tryCatch()` inside a function

The second example avoids the above problem by invoking `tryCatch()` *inside* our user-defined function. The principle is very much the same as before: We're going to tell R what to give us whenever it encounters an error. However, we are going to be more explicit about where we expect that error to occur. Moreover, instead of simply producing an error message, this time we'll instruct R to return an explicit, alternative value (i.e. `NA`).

```{r square_trycatch}
square_trycatch <-
  function (x = 1) {
    x_sq <- tryCatch(x^2, error = function(e) NA_real_) ## tryCatch goes here now. Produce an NA value if we can't square the input.
    df <- tibble(value=x, value_squared=x_sq)
    return(df)
  }
```

Let's see that it works on our previous input vector, where only one input was invalid.

```{r square_trycatch_test1}
square_trycatch(c(1,2,"three"))
```

Huh? Looks like it half worked. We get the input values, but R's vectorised nature (normally such a good thing!) has converted *all* of the squared output values to `NA` because of the one bad apple. Why? Well, let's look at our input vector again:

```{r square_trycatch_test2}
str(c(1,2,"three"))
```

*Ah-ha...* R has converted every element in the vector to a character string. Remember that vectors in R are assumed to contain only elements of the same type. The solution is to use an input array that allows different element types --- i.e. a *list*. This, in turn, requires modifying the way that we invoke the function by putting it in a `base::lapply()` or `purrr::map()` call. As you'll hopefully remember from the last lecture, these two functions are syntactically identical.

```{r square_trycatch_test3}
## Using base::lapply
lapply(list(1,2,"three"), square_trycatch) 
## Using purrr:map
map(list(1,2,"three"),  square_trycatch) 
```

As we practiced last lecture, we may wish to bind the resulting list of data frames into a single data frame using `dplyr::bind_rows()` or, more simply, `purrr::map_df()`. However, that actually produces errors of its own because all of the columns need to be the same. 

```{r square_trycatch_test4, error=T}
map_df(list(1,2,"three"),  square_trycatch)
```

The somewhat pedantic solution is to make sure that the offending input is coerced to a numeric within the function itself. Note that this will introduce coercion warnings of its own, but at least it won't fail. 

```{r square_trycatch2}
square_trycatch2 <-
  function (x = 1) {
    x_sq <- tryCatch(x^2, error = function(e) NA_real_) 
    df <- tibble(value=as.numeric(x), value_squared=x_sq) ## Convert input to numeric
    return(df)
  }

map_df(list(1,2,"three"), square_trycatch2)
```

### Option 3: Use `purrr::safely()` and family

Finally, for those of you who prefer a tidyverse equivalent of `tryCatch()`, you can use `purrr::safely()` and its related functions (including `purrr::possibly()` and other variants). I won't go through the entire rigmarole again, so here's a simple flavour of how they work:

```{r square_safely1}
square_simple <-
  function (x = 1) {
    x_sq <- x^2
  }
square_safely <- safely(square_simple)
square_safely("three")
square_safely("three")$result
```

And you can specify default behaviour:

```{r square_safely2}
square_safely <- safely(square_simple, otherwise = NA_real_)
square_safely("three")
square_safely("three")
```


## Caching (memoization)

We've already experienced the benefits (and occasional frustrations) of caching with R Markdown documents.^[Like all of my notes for the course, this lecture is written in R Markdown and then "knitted" to HTML. If you look at the top of the .Rmd source file, you'll see that I have a code chunk saying `knitr::opts_chunk$set(echo = TRUE, **cache = TRUE**, dpi=300)`. The bit in bold causes each code chunk to be cached so that it doesn't have to be re-run every time I recompile the document (unless something changes).] Caching can also be extremely for during regular programming and analysis. Functions can crash midway through for a host of reasons: invalid arguments buried in iterated input, computer malfunction, memory limits, power outtages, timeouts, etc. This can be a soul-splintering experience if you're working on a particularly lengthy simulation or computation problem. We'll get to parallel computation next lecture, but the problem is *even worse* there. Typically what happens with a parallelized function is that the entire run will complete (potentially taking many hours or days) and only reveal an error right at the end... with no saved output! 

<iframe src="https://giphy.com/embed/fVfnOJ0oLb87m" width="480" height="359" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></p>

Fortunately, R has our back with several caching tools. I'm going to focus here on the [R.cache package](https://cran.r-project.org/web/packages/R.cache/index.html) from [Henrik Bengtsson](https://twitter.com/henrikbengtsson). I should perhaps also clarify that there are various forms of caching, but we're going to be practicing here is technically known as [memoization](https://en.wikipedia.org/wiki/Memoization).

Let's start by creating a "slow" version of our simple square function, `slow_func()`, which will sleep for two seconds at the end of every iteration. Of course, this is just meant to emulate a computationally-intensive function, but the basic ideas will carry through entirely intact.

```{r slow_func}
## Emulate slow function
slow_func <- 
  function(x = 1) {
    x_sq <- x^2 
    df <- tibble(value=x, value_squared=x_sq)
    Sys.sleep(2)
    return(df)
    }
```

Now we layer on the caching functionality. To do this, we're going to wrap our slow function in a parent function, which I'll creatively call `cached_func()`. This parent function has two primary sections:

1. First, it tries to load previously cached data (if it exists) using `R.cache::loadCache()`. This works by recognising a unique file cache for a given set of input parameters, which we would have generated previously. Speaking of which...
2. Second, it runs our slow function on any inputs that have not already been evaluated. During each iteration, we generate a new cache file using `R.cache::saveCache()`. This will save the compressed output from that iteration to disk (i.e. in our `~/.Rcache` directory) and automatically append a unique ID (hexadecimal hash code) to the file name, for convenient recall later.

```{r cached_func}
# library(R.cache) ## Already loaded

cached_func <- 
  function(x) {
    
    ## 1. Try to load cached data, if already generated
    key <- list(x)
    my_data <- loadCache(key)
    if (!is.null(my_data)) {
      cat("Loaded cached data\n")
      return(my_data)
    }
    
    ## 2. If not available, generate it.
    cat("Generating data from scratch...")
    my_data <- slow_func(x)
    cat("ok\n")
    saveCache(my_data, key=key, comment="slow_func()")
    
    return(my_data)
  }
```

There are obviously a couple of other things happening in the function (e.g. writing helpful messages to ourselves with `cat()`), but hopefully you've understood the main points. Now let's iterate over our function using a particular set of inputs (i.e. the numbers 1 through 10). Note that I'm going to use the lightweight [tictoc package](https://cran.r-project.org/web/packages/tictoc/) to record timing.

```{r cache_run1}
# library(tictoc) ## Already loaded
tic()
map_df(1:10, cached_func)
toc()
```

As expected, this produced exactly the same output as our regular `square()` function, but it just took longer (20 seconds to be precise). The function produced some real-time feedback for us with the "Generating data from scratch... ok" message, because we asked it to. This is probably less impressive in a knitted R Markdown document, but I've found it can be very informative in a live coding session.^[Challenge: I usually include the input or iteration run in my message, so that I know where I am in the sequence. How would you do this?]

Okay, now let's try running the function for a second time to see if caching makes a difference...

```{r cache_run2}
tic()
map_df(1:10, cached_func)
toc()
```

And does it ever! We're down to a fraction of a second, since we didn't need to run at all again. Rather, we simply read in the previously saved (i.e. cached) results.

Finally, note that our caching function is smart enough to disguish between previously cached and non-cached results. For example, consider what happens if I include five more numbers in the `x` input vector.

```{r cache_run3}
tic()
map_df(1:15, cached_func)
toc()
```

As expected, our function only generated the new observations from scratch. The remaining inputs were loaded from the cache. You can think of this as approximating a real-life case, where your program crashes/halts midway through its run, and you don't need to restart all the way at the beginning. No jokes, this happens more frequently than you might expect, especially when you're working with complex analyses and certain high-performance computing tools (e.g. preemptible nodes or virtual machines instances). Caching has saved me *many* lost hours and it could do the same for you.

## Further resources

- Amanda Gadrow has a great video about [*Debugging techniques in RStudio*](https://www.rstudio.com/resources/videos/debugging-techniques-in-rstudio/).
- While it seems somewhat childish to recommend a whole on advanced topics, I would be remiss not to mention Hadley Wickham's [*Advanced R*](http://adv-r.had.co.nz/) again. In truth, he doesn't really cover the same topics as I have here, but there's a great deal of relevant knowledge to be gleaned from it. If you're looking to scale up your understanding of how R works underneath the hood and implement some truly high-performance code, then this is where you should go next.
